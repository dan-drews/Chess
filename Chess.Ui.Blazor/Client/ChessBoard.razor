@using ChessLibrary
<h3>ChessBoard</h3>

@code {

    Game g;
    List<(Files f, int rank)> TargetedSquares = new List<(Files f, int rank)>();
    SquareState selectedSquare;

    protected override void OnInitialized()
    {
        g = new Game();
        g.ResetGame();
    }

    void GenerateMove()
    {
        var move = Engine.GetBestMove(g, g.PlayerToMove);
        g.AddMove(move);
    }

    void HandleSquareClick(SquareState s)
    {
        Console.WriteLine($"{s.Square.Rank}{s.Square.File}");
        Console.WriteLine(s.Piece);
        Console.WriteLine(selectedSquare);
        if (s.Piece != null && selectedSquare == null)
        {
            TargetedSquares.Clear();
            selectedSquare = s;
            var moves = MoveLegalityEvaluator.GetAllLegalMoves(g.Board, s, false);
            foreach (var m in moves)
            {
                TargetedSquares.Add((m.DestinationSquare.File, m.DestinationSquare.Rank));
            }
        }
        else
        {
            if (selectedSquare != null)
            {
                if (TargetedSquares.Contains((s.Square.File, s.Square.Rank)))
                {
                    g.AddMove(new Move(selectedSquare.Piece, selectedSquare.Piece.Color, selectedSquare.Square, s.Square)
                    {
                        CapturedPiece = s.Piece
                    });
                }
            }
            selectedSquare = null;
            TargetedSquares.Clear();
        }
    }

    string GetPieceSymbol(Piece p)
    {
        if (p == null)
        {
            return "";
        }
        if (p.Color == Colors.White)
        {
            switch (p.Type)
            {
                case PieceTypes.Pawn:
                    return "♙";
                case PieceTypes.Bishop:
                    return "♗";
                case PieceTypes.Rook:
                    return "♖";
                case PieceTypes.Queen:
                    return "♕";
                case PieceTypes.King:
                    return "♔";
                case PieceTypes.Knight:
                    return "♘";
            }
        }
        else
        {
            switch (p.Type)
            {
                case PieceTypes.Pawn:
                    return "♟";
                case PieceTypes.Bishop:
                    return "♝";
                case PieceTypes.Rook:
                    return "♜";
                case PieceTypes.Queen:
                    return "♛";
                case PieceTypes.King:
                    return "♚";
                case PieceTypes.Knight:
                    return "♞";
            }
        }
        return "";
    }

}

<table style="border: 1px solid black;">
    @for (int i = 8; i >= 1; i--)
    {
        <tr>
            <td>@i</td>
            @for (Files f = Files.A; f <= Files.H; f++)
            {
                SquareState state = g.Board.GetSquare(f, i);
                <td style="height: 75px; width: 75px; background-color: @(state.Square.Color == Colors.White ? "white" : "black"); color:@(state.Piece?.Color == Colors.White ? "white" : "black"); stroke: @(state.Square?.Color == Colors.White ? "black" : "white"); stroke-width: 20; font-size: 36px; text-align: center" @onclick="() => HandleSquareClick(state)">
                    @if (state.Piece != null)
                    {
                        if (state.Piece.Type == PieceTypes.Pawn)
                        {
                            <span>
                                <i class="fas fa-chess-pawn"></i>
                            </span>
                        }
                        else if (state.Piece.Type == PieceTypes.Rook)
                        {
                            <span>
                                <i class="fas fa-chess-rook"></i>
                            </span>
                        }
                        else if (state.Piece.Type == PieceTypes.Knight)
                        {
                            <span>
                                <i class="fas fa-chess-knight"></i>
                            </span>
                        }
                        else if (state.Piece.Type == PieceTypes.Bishop)
                        {
                            <span>
                                <i class="fas fa-chess-bishop"></i>
                            </span>
                        }
                        else if (state.Piece.Type == PieceTypes.Queen)
                        {
                            <span>
                                <i class="fas fa-chess-queen"></i>
                            </span>
                        }
                        else if (state.Piece.Type == PieceTypes.King)
                        {
                            <span>
                                <i class="fas fa-chess-king"></i>
                            </span>
                        }
                    }
                    @if (TargetedSquares.Any(x => x.f == f && x.rank == i))
                    {
                        <span style="color: @(state.Square.Color == Colors.White ? "black" : "white")">X</span>
                    }
                </td>
            }
        </tr>
    }
    <tr>
        <td style="text-align: center"></td>
        <td style="text-align: center">A</td>
        <td style="text-align: center">B</td>
        <td style="text-align: center">C</td>
        <td style="text-align: center">D</td>
        <td style="text-align: center">E</td>
        <td style="text-align: center">F</td>
        <td style="text-align: center">G</td>
        <td style="text-align: center">H</td>
    </tr>
</table>
<button @onclick="GenerateMove">Generate Next Move</button>
<div>
    <h2>Moves</h2>
    @foreach(var m in g.Moves)
    {
        <p>@($"{m.StartingSquare.File}{m.StartingSquare.Rank} → {m.DestinationSquare.File}{m.DestinationSquare.Rank}")</p>
    }
</div>